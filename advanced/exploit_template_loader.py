"""Loader for advanced exploit flow templates."""

from __future__ import annotations

import os
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any, Iterable

import yaml


@dataclass
class ExploitStage:
    """Represents a single stage in an exploit template."""

    name: str
    objective: str
    actions: List[str] = field(default_factory=list)
    detection_signatures: Dict[str, List[str]] = field(default_factory=dict)
    poc_snippet: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "objective": self.objective,
            "actions": list(self.actions),
            "detection_signatures": {k: list(v) for k, v in self.detection_signatures.items()},
            "poc_snippet": self.poc_snippet,
        }


@dataclass
class ExploitTemplateDefinition:
    """In-memory representation of an exploit template definition."""

    template_id: str
    name: str
    description: str
    severity: str
    tags: List[str]
    vulnerability_classes: List[str]
    stages: List[ExploitStage]
    detection_signatures: Dict[str, List[str]]
    poc_skeletons: Dict[str, Dict[str, Any]]
    historical_references: List[Dict[str, Any]]
    provenance: Dict[str, Any] = field(default_factory=dict)
    metrics: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "metadata": {
                "id": self.template_id,
                "name": self.name,
                "description": self.description,
                "severity": self.severity,
                "tags": list(self.tags),
                "vulnerability_classes": list(self.vulnerability_classes),
            },
            "stages": [stage.to_dict() for stage in self.stages],
            "detection_signatures": {k: list(v) for k, v in self.detection_signatures.items()},
            "poc_skeletons": self.poc_skeletons,
            "historical_references": list(self.historical_references),
            "provenance": dict(self.provenance),
            "metrics": dict(self.metrics),
        }


class ExploitTemplateLoader:
    """Loads exploit flow templates from YAML files and tracks usage metrics."""

    def __init__(self, template_dir: Optional[str] = None) -> None:
        self.template_dir = template_dir or os.path.join(
            os.path.dirname(os.path.dirname(__file__)), "templates", "exploit_flows"
        )
        self.templates: Dict[str, ExploitTemplateDefinition] = {}
        self.templates_by_class: Dict[str, List[str]] = {}
        self._load_templates()

    def _load_templates(self) -> None:
        if not os.path.isdir(self.template_dir):
            return

        for entry in sorted(os.listdir(self.template_dir)):
            if not entry.endswith((".yaml", ".yml")):
                continue

            path = os.path.join(self.template_dir, entry)
            with open(path, "r", encoding="utf-8") as handle:
                data = yaml.safe_load(handle) or {}

            template = self._parse_template(data, entry)
            if not template:
                continue

            self.templates[template.template_id] = template
            for vuln_class in template.vulnerability_classes:
                key = vuln_class.lower()
                self.templates_by_class.setdefault(key, []).append(template.template_id)

    def _parse_template(
        self, data: Dict[str, Any], filename: str
    ) -> Optional[ExploitTemplateDefinition]:
        metadata = data.get("metadata", {})
        template_id = metadata.get("id") or os.path.splitext(filename)[0]
        name = metadata.get("name", template_id)
        description = metadata.get("description", "")
        severity = metadata.get("severity", "unknown")
        tags = metadata.get("tags", [])
        vulnerability_classes = metadata.get("vulnerability_classes", [])

        stages_data = data.get("stages", [])
        stages = [
            ExploitStage(
                name=stage.get("name", ""),
                objective=stage.get("objective", ""),
                actions=stage.get("actions", []) or [],
                detection_signatures=stage.get("detection_signatures", {}) or {},
                poc_snippet=stage.get("poc_snippet", ""),
            )
            for stage in stages_data
            if stage
        ]

        detection_signatures = data.get("detection_signatures", {}) or {}
        poc_skeletons = data.get("poc_skeletons", {}) or {}
        historical_references = data.get("historical_references", []) or []
        provenance = data.get("provenance", {}) or {}
        metrics = data.get("metrics", {}) or {}

        metrics.setdefault("usage_count", 0)
        metrics.setdefault("execution_count", 0)
        metrics.setdefault("success_count", 0)
        metrics.setdefault("last_used", None)
        metrics.setdefault("last_success", None)
        metrics.setdefault("recent_context", [])
        metrics.setdefault("success_rate", 0.0)

        return ExploitTemplateDefinition(
            template_id=template_id,
            name=name,
            description=description,
            severity=severity,
            tags=tags,
            vulnerability_classes=vulnerability_classes,
            stages=stages,
            detection_signatures=detection_signatures,
            poc_skeletons=poc_skeletons,
            historical_references=historical_references,
            provenance=provenance,
            metrics=metrics,
        )

    def get_templates_for_class(self, vulnerability_class: str) -> List[ExploitTemplateDefinition]:
        """Return templates matching a vulnerability class."""

        ids = self.templates_by_class.get(vulnerability_class.lower(), [])
        return [self.templates[template_id] for template_id in ids]

    def get_template(self, template_id: str) -> Optional[ExploitTemplateDefinition]:
        """Return template by identifier."""

        return self.templates.get(template_id)

    def list_templates(self) -> Iterable[ExploitTemplateDefinition]:
        """Iterate over all loaded templates."""

        return self.templates.values()

    def record_usage(
        self,
        template_id: str,
        success: Optional[bool] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> None:
        """Update metrics for a template usage."""

        template = self.templates.get(template_id)
        if not template:
            return

        metrics = template.metrics
        metrics["usage_count"] = metrics.get("usage_count", 0) + 1
        metrics["last_used"] = datetime.utcnow().isoformat()

        if context:
            recent_context = metrics.setdefault("recent_context", [])
            recent_context.append({"timestamp": metrics["last_used"], **context})
            # Keep only the last five entries
            metrics["recent_context"] = recent_context[-5:]

        if success is None:
            metrics.setdefault("last_success", None)
            return

        metrics["execution_count"] = metrics.get("execution_count", 0) + 1
        if success:
            metrics["success_count"] = metrics.get("success_count", 0) + 1

        executed = metrics.get("execution_count", 0)
        if executed:
            metrics["success_rate"] = metrics.get("success_count", 0) / executed
        metrics["last_success"] = success

    def to_serializable(self) -> Dict[str, Any]:
        """Return serializable representation of all templates."""

        return {template_id: template.to_dict() for template_id, template in self.templates.items()}


__all__ = [
    "ExploitTemplateLoader",
    "ExploitTemplateDefinition",
    "ExploitStage",
]
