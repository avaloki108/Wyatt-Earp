metadata:
  id: gas-griefing-001
  name: Cross-Chain Gas Griefing Vector
  description: >-
    Documents exploitation of gas reimbursement or refund mechanisms where an
    attacker can force relayers or keepers to spend excessive gas, exhausting
    incentives and halting service.
  severity: medium
  tags:
    - gas_griefing
    - relayer_economics
    - griefing
  vulnerability_classes:
    - gas_griefing
    - relayer_economic_attack
  historical_references:
    - incident: StarkNet L1 gas griefing report
      year: 2022
      details: Attackers could relay spam messages to exhaust relayer reimbursements.
      link: https://research.starknet.io
    - incident: Keeper Network DoS via refund abuse
      year: 2020
      details: Refund multiplier allowed malicious actors to bankrupt automation keepers.
      link: https://keeperdao.com/blog
provenance:
  source: Gas Economics Study Group
  contributor: Infrastructure Reliability Unit
  last_reviewed: 2024-02-11
  confidence: medium
stages:
  - name: Incentive Model Audit
    objective: Understand relayer reimbursement rules and limits.
    actions:
      - Inspect contract functions calculating gas refunds.
      - Simulate relayer calls with varying gas usage.
      - Determine maximum reimbursable gas per task.
    detection_signatures:
      onchain:
        - RefundPaid events pegged to gasUsed inputs
        - high gasLimit values passed to automation executors
      offchain:
        - relayer dashboards showing negative margins
    poc_snippet: |
      uint256 refund = automation.computeRefund(500_000);
      emit log_uint(refund);
  - name: Grief Payload Crafting
    objective: Build transactions that consume gas without progressing system state.
    actions:
      - Loop operations on minimal impact state (e.g., reading logs repeatedly).
      - Use cross-contract calls that revert at end, still burning gas.
      - Abuse calldata growth to push execution to refund cap.
    detection_signatures:
      onchain:
        - repeated task execution reverting with same selector
        - gas consumption spike without correlated state changes
      offchain:
        - relayer error logs citing out-of-gas or reimbursement mismatch
    poc_snippet: |
      automation.executeTask(abi.encodePacked(bytes32(0), new bytes(3200)));
  - name: Relay Exhaustion
    objective: Drain relayer incentives until service halts.
    actions:
      - Submit grief payloads from multiple addresses.
      - Monitor relayer balance depletion.
      - Observe automation queue backlog growth.
    detection_signatures:
      onchain:
        - relayer balance trending to zero
        - automation queue length rising sharply
      offchain:
        - monitoring alerts for relayer insolvency
    poc_snippet: |
      uint256 before = automation.relayerFunds(relayer);
      automation.executeTask(griefPayload);
      assertLt(automation.relayerFunds(relayer), before);
  - name: Documentation
    objective: Provide mitigation and reproduction steps for defenders.
    actions:
      - Record gas traces for grief payload transactions.
      - Suggest rate limits or commitment fees.
      - Outline safe refund formula adjustments.
    detection_signatures:
      onchain:
        - presence of RefundCapped events after mitigation patch
      offchain:
        - incident reports acknowledging reimbursement tuning
    poc_snippet: |
      console.log("Relayer exhausted");
detection_signatures:
  onchain:
    - repeated executeTask calls reverting with same calldata hash
    - relayer funds decreasing despite failed automation tasks
  offchain:
    - infrastructure alerts for negative relayer ROI
poc_skeletons:
  foundry:
    required_imports:
      - forge-std/Test.sol
    setup_outline: Deploy automation contract with refund logic, seed relayer balance.
    exploit_outline: Send grief payloads, measure gas usage, assert relayer reimbursement exploited.
    validation_outline: Ensure relayer funds drop and automation queue stalls.
    code: |
      // SPDX-License-Identifier: MIT
      pragma solidity ^0.8.19;

      import "forge-std/Test.sol";
      import "../src/{contract_name}.sol";

      contract GasGriefingExploit is Test {
          {contract_name} automation;
          address relayer = address(0xCAFE);

          function setUp() public {
              automation = new {contract_name}();
              automation.depositForRelayer{value: 50 ether}(relayer);
          }

          function testGasGrief() public {
              bytes memory griefPayload = abi.encodePacked(uint256(0), new bytes(2048));
              automation.executeTask(griefPayload);
              automation.executeTask(griefPayload);

              assertLt(automation.relayerFunds(relayer), 50 ether);
          }
      }
  hardhat:
    required_imports:
      - "hardhat"
    setup_outline: Deploy automation contract, top up relayer, craft grief payload script.
    exploit_outline: Execute payload repeatedly, log gas usage, observe relayer balance decline.
    validation_outline: Assert queue growth or relayer pause event triggered.
    code: |
      const { ethers } = require("hardhat");

      describe("Gas Griefing", function () {
        it("drains relayer incentives", async function () {
          // TODO: send grief transactions and assert balances
        });
      });
metrics:
  baseline_success_rate: 0.24
  references_tested: 2
