metadata:
  id: bridge-replay-001
  name: Cross-Chain Bridge Replay Attack
  description: >-
    Focuses on message-passing bridges where signature replay or delayed
    finality enables reuse of withdrawal proofs on secondary chains.
  severity: high
  tags:
    - bridge
    - replay
    - cross_chain
  vulnerability_classes:
    - bridge_replay
    - delayed_finality
  historical_references:
    - incident: Poly Network bridge replay
      year: 2021
      details: Replayable cross-chain messages enabled unauthorized withdrawals.
      link: https://medium.com/poly-network/poly-network-attack-analysis-5fbb1459ff79
    - incident: Qubit QBridge exploit
      year: 2022
      details: Crafted messages bypassed verification to mint bridged assets repeatedly.
      link: https://qubit.org/postmortem
provenance:
  source: Interop Threat Collective
  contributor: Bridge Analysis Pod
  last_reviewed: 2024-02-29
  confidence: medium
stages:
  - name: Message Surface Recon
    objective: Catalogue message formats, signature schemes, and nonce management.
    actions:
      - Retrieve bridge ABI and event topics for message submission.
      - Analyze Merkle proofs and root rotation cadence.
      - Inspect nonce or replay protection for each channel.
    detection_signatures:
      onchain:
        - MessageSent events lacking per-chain nonce increments
        - ProofSubmitted without subsequent state root update
      offchain:
        - relayer dashboards showing delayed finality or congestion
    poc_snippet: |
      bytes32 root = bridge.currentRoot();
      emit log_bytes32(root);
  - name: Proof Harvesting
    objective: Capture legitimate withdrawal proof and identify reuse window.
    actions:
      - Observe target chain transactions and extract proof payloads.
      - Simulate finality lag to determine safe replay window.
      - Craft custom proof replicating original signature set.
    detection_signatures:
      onchain:
        - repeated ProofSubmitted payloads
        - withdrawal events referencing same depositId
      offchain:
        - relayer logs confirming message queue backlog
    poc_snippet: |
      bytes memory proof = abi.encode(originalProof);
      assertTrue(bridge.verifyProof(proof));
  - name: Replay Execution
    objective: Submit harvested proof on alternate chain or after reorg to withdraw funds twice.
    actions:
      - Deploy helper to bypass destination chain access control.
      - Submit identical proof before nonce update.
      - Withdraw bridged assets into attacker-controlled wallet.
    detection_signatures:
      onchain:
        - Withdrawn events emitted twice for same depositId
        - sudden drop in bridge vault balance
      offchain:
        - monitoring alerts for duplicate proof detection
    poc_snippet: |
      bridge.executeWithdraw(proof, payload);
      assertEq(token.balanceOf(attacker), expected);
  - name: Validation and Countermeasures
    objective: Confirm replay succeeded and outline remediation steps.
    actions:
      - Compare vault balances pre/post replay.
      - Document nonce handling bug and propose fix (chain-specific nonce or bitmaps).
      - Highlight requirement for optimistic guard delays.
    detection_signatures:
      onchain:
        - vaultAudit() reporting mismatch vs root ledger
      offchain:
        - incident response dashboards raising replay flag
    poc_snippet: |
      assertEq(bridge.getProcessedNonce(depositId), 0);
detection_signatures:
  onchain:
    - duplicate ProofSubmitted events within same block range
    - withdrawal receipts referencing stale root hash
  offchain:
    - relayer metrics showing backlog > 95th percentile
poc_skeletons:
  foundry:
    required_imports:
      - forge-std/Test.sol
    setup_outline: Deploy mock bridge contracts, capture legitimate proof, simulate finality lag.
    exploit_outline: Call executeWithdraw twice with same proof before nonce increments, assert double withdrawal.
    validation_outline: Compare vault balances and processed nonce state after exploit.
    code: |
      // SPDX-License-Identifier: MIT
      pragma solidity ^0.8.19;

      import "forge-std/Test.sol";
      import "../src/{contract_name}.sol";

      contract BridgeReplayExploit is Test {
          {contract_name} bridge;
          address attacker = address(this);

          function setUp() public {
              bridge = new {contract_name}();
          }

          function testReplay() public {
              bytes memory proof = bridge.getSampleProof();
              bridge.executeWithdraw(proof);
              bridge.executeWithdraw(proof);

              assertGt(bridge.balanceOf(attacker), 0);
          }
      }
  hardhat:
    required_imports:
      - "hardhat"
    setup_outline: Fork destination chain, capture transaction proof, replay using ethers.js helpers.
    exploit_outline: Submit identical proof twice, ensure nonce not updated, drain vault.
    validation_outline: Confirm duplicate Withdrawn events and balances.
    code: |
      const { ethers } = require("hardhat");

      describe("Bridge Replay", function () {
        it("replays proof", async function () {
          // TODO: implement full replay steps
        });
      });
metrics:
  baseline_success_rate: 0.29
  references_tested: 4
