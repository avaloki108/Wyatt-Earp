metadata:
  id: signature-malleability-001
  name: Signature Malleability Exploit Chain
  description: >-
    Demonstrates abusing malleable signatures or missing domain separation to
    replay signed payloads across contexts, escalating privileges or bypassing
    nonce checks.
  severity: high
  tags:
    - signature_malleability
    - replay
    - domain_separator
  vulnerability_classes:
    - signature_malleability
    - weak_signature_domain
  historical_references:
    - incident: dYdX malleability disclosure
      year: 2020
      details: Lack of strict nonces allowed replay of off-chain orders with tweaked signatures.
      link: https://dydx.exchange/blog
    - incident: OpenSea Seaport signature domain issue
      year: 2022
      details: Incorrect domain separation created reuse surface across chains.
      link: https://opensea.io/blog
provenance:
  source: Signature Safety Initiative
  contributor: Cryptography Review Board
  last_reviewed: 2024-03-19
  confidence: high
stages:
  - name: Surface Enumeration
    objective: Identify signature schemes, domain separators, and nonce logic.
    actions:
      - Inspect EIP-712 domain separator and version fields.
      - Review nonce/sequence storage and reset conditions.
      - Capture signed payload samples from mempool or logs.
    detection_signatures:
      onchain:
        - Permit or meta-transaction events lacking nonce increment
        - identical signatures appearing across different chainIds
      offchain:
        - API logs showing repeated payloads per signer
    poc_snippet: |
      bytes32 domain = target.domainSeparator();
      emit log_bytes32(domain);
  - name: Malleability Crafting
    objective: Adjust signature values to pass verification while representing same intent.
    actions:
      - Flip `s` value to its negation modulo secp256k1 order.
      - Adjust v parameter for chain-specific acceptance.
      - Replay payloads on alternate domain where domain separator missing chainId.
    detection_signatures:
      onchain:
        - permit executed twice with same nonce
        - low-level call verifying signature with `s > secp256k1n/2`
      offchain:
        - wallet telemetry noticing repeated approvals
    poc_snippet: |
      (uint8 v, bytes32 r, bytes32 s) = _mutateSignature(originalSig);
  - name: Exploitation
    objective: Use malleable signature to perform unauthorized action.
    actions:
      - Submit replayed permit to drain tokens.
      - Execute meta-transaction on behalf of victim.
      - Escalate privileges by setting admin role via signed message.
    detection_signatures:
      onchain:
        - Transfer events triggered by metaTx relayer
        - RoleGranted events referencing attacker address
      offchain:
        - user complaints about unexpected approvals
    poc_snippet: |
      target.permit(victim, attacker, amount, deadline, v, r, s);
  - name: Validation and Hardening Guidance
    objective: Confirm replay succeeded and recommend mitigations.
    actions:
      - Demonstrate nonce unchanged after replay.
      - Document missing domain fields or signature checks.
      - Recommend enforcing EIP-2 s-range and per-chain domain.
    detection_signatures:
      onchain:
        - nonce storage unchanged post-exploit
      offchain:
        - audit reports referencing domain separator fix
    poc_snippet: |
      assertEq(target.nonces(victim), originalNonce);
detection_signatures:
  onchain:
    - identical permits accepted on multiple chains
    - signatures with s-value > secp256k1n/2 passing validation
  offchain:
    - phishing reports tied to permit replays
poc_skeletons:
  foundry:
    required_imports:
      - forge-std/Test.sol
    setup_outline: Deploy token with permit, issue victim approval, capture signature, mutate s value.
    exploit_outline: Replay permit with mutated signature, transfer tokens to attacker.
    validation_outline: Assert nonce unchanged and attacker balance increased.
    code: |
      // SPDX-License-Identifier: MIT
      pragma solidity ^0.8.19;

      import "forge-std/Test.sol";
      import "../src/{contract_name}.sol";

      contract SignatureMalleabilityExploit is Test {
          {contract_name} token;
          address victim = address(0xB0B);
          address attacker = address(this);

          function setUp() public {
              token = new {contract_name}();
              token.mint(victim, 1000 ether);
          }

          function testSignatureReplay() public {
              (uint8 v, bytes32 r, bytes32 s) = token.getSampleSignature(victim);
              (uint8 v2, bytes32 r2, bytes32 s2) = mutateSignature(v, r, s);
              token.permit(victim, attacker, 100 ether, block.timestamp + 1 hours, v2, r2, s2);
              token.transferFrom(victim, attacker, 100 ether);
              assertEq(token.nonces(victim), 0);
          }
      }
  hardhat:
    required_imports:
      - "hardhat"
    setup_outline: Deploy permit-enabled token, capture signature, mutate and replay via script.
    exploit_outline: Submit mutated signature transaction, drain tokens, verify nonce unchanged.
    validation_outline: Assert balances and log mutated signature parameters.
    code: |
      const { ethers } = require("hardhat");

      describe("Signature Malleability", function () {
        it("replays permit", async function () {
          // TODO: mutate signature and replay permit
        });
      });
metrics:
  baseline_success_rate: 0.35
  references_tested: 4
