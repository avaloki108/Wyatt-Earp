metadata:
  id: lp-rounding-001
  name: Liquidity Pool Rounding Drift
  description: >-
    Highlights exploits where precision loss or rounding bias in AMM math
    enables gradual extraction of value via repeated joins/exits or swaps.
  severity: medium
  tags:
    - amm
    - rounding
    - precision_loss
  vulnerability_classes:
    - liquidity_pool_rounding
    - precision_loss
  historical_references:
    - incident: Balancer rounding arbitrage
      year: 2020
      details: Attackers exploited pool rounding to drain high value tokens gradually.
      link: https://balancer.fi/blog
    - incident: Curve pool rounding bug
      year: 2021
      details: Virtual price calculation allowed dust extraction over multiple trades.
      link: https://curve.fi/news
provenance:
  source: AMM Exploit Study
  contributor: Liquidity Reliability Team
  last_reviewed: 2024-03-02
  confidence: medium
stages:
  - name: Precision Audit
    objective: Understand token decimals, invariant math, and rounding direction.
    actions:
      - Review swap and join formulas for division rounding.
      - Simulate high precision trades vs actual executed trades.
      - Identify tokens with disparate decimals.
    detection_signatures:
      onchain:
        - swap events with minimal delta but positive profit
        - join/exit operations alternating in same block
      offchain:
        - analytics showing constant positive slippage to same address
    poc_snippet: |
      uint256 virtualPrice = pool.getVirtualPrice();
      emit log_uint(virtualPrice);
  - name: Drift Accumulation Strategy
    objective: Determine optimal repetition count and trade size to accumulate rounding drift.
    actions:
      - Run Monte Carlo over swap sizes.
      - Identify break-even after gas costs.
      - Automate loops to rotate between assets.
    detection_signatures:
      onchain:
        - sequential swaps alternating token order
        - liquidity tokens minted/burned rapidly by same address
      offchain:
        - monitoring dashboards flagging dust extraction pattern
    poc_snippet: |
      for (uint256 i = 0; i < 50; i++) {
          pool.swap(tokenA, tokenB, amount);
      }
  - name: Execution
    objective: Run strategy and harvest rounding bias gains.
    actions:
      - Execute repetitive swaps or joins/exits.
      - Track cumulative profit after each iteration.
      - Withdraw gains to secure wallet.
    detection_signatures:
      onchain:
        - cumulative profit despite neutral price movement
      offchain:
        - arbitrage monitoring noting unusual dust profits
    poc_snippet: |
      uint256 before = tokenB.balanceOf(attacker);
      pool.swap(tokenA, tokenB, amount);
      assertGt(tokenB.balanceOf(attacker), before);
  - name: Reporting
    objective: Provide reproduction details and recommended fixes.
    actions:
      - Document precision mismatch and rounding direction.
      - Suggest fixed-point library upgrade or floor/ceil adjustments.
      - Provide statistical evidence of drift.
    detection_signatures:
      onchain:
        - updates to pool math functions post-report
      offchain:
        - governance proposals referencing rounding fix
    poc_snippet: |
      console.log("Rounding drift documented");
detection_signatures:
  onchain:
    - consistent dust profits captured by same address within short intervals
    - LP share supply oscillating while pool balances remain static
  offchain:
    - analytics dashboards flagging rounding arbitrage
poc_skeletons:
  foundry:
    required_imports:
      - forge-std/Test.sol
    setup_outline: Deploy AMM with mismatched decimals, seed liquidity, approve attacker.
    exploit_outline: Perform looped swaps exploiting rounding, track profit accumulation.
    validation_outline: Assert attacker balance increases while invariant roughly stable.
    code: |
      // SPDX-License-Identifier: MIT
      pragma solidity ^0.8.19;

      import "forge-std/Test.sol";
      import "../src/{contract_name}.sol";

      contract RoundingDriftExploit is Test {
          {contract_name} pool;
          IERC20 tokenA;
          IERC20 tokenB;
          address attacker = address(this);

          function setUp() public {
              pool = new {contract_name}();
              tokenA = pool.tokenA();
              tokenB = pool.tokenB();
              tokenA.approve(address(pool), type(uint256).max);
              tokenB.approve(address(pool), type(uint256).max);
          }

          function testRoundingDrift() public {
              uint256 before = tokenB.balanceOf(attacker);
              for (uint256 i = 0; i < 30; i++) {
                  pool.swap(address(tokenA), address(tokenB), 1e12);
              }
              assertGt(tokenB.balanceOf(attacker), before);
          }
      }
  hardhat:
    required_imports:
      - "hardhat"
    setup_outline: Deploy or fork AMM, script repeated swaps, track profits.
    exploit_outline: Run rounding exploitation script via ethers.js, chart cumulative gains.
    validation_outline: Confirm profits exceed gas and pool balances remain near-constant.
    code: |
      const { ethers } = require("hardhat");

      describe("Liquidity Pool Rounding", function () {
        it("extracts rounding dust", async function () {
          // TODO: run swap loop and assert profit
        });
      });
metrics:
  baseline_success_rate: 0.27
  references_tested: 3
