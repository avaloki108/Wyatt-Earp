metadata:
  id: governance-queue-001
  name: Governance Queue Manipulation Attack
  description: >-
    Targets timelock or governance queue mechanics where proposal ordering can
    be shifted to execute malicious payloads ahead of defender interventions.
  severity: high
  tags:
    - governance
    - timelock
    - queue_jumping
  vulnerability_classes:
    - governance_queue_manipulation
    - timelock_bypass
  historical_references:
    - incident: Beanstalk governance attack
      year: 2022
      details: Flash loan voting power executed malicious proposal in a single block.
      link: https://bean.money/blog
    - incident: PancakeSwap queue manipulation report
      year: 2021
      details: Proposal queue could be reordered by canceling and resubmitting with crafted timestamps.
      link: https://pancakeswap.finance
provenance:
  source: DAO Security Watchlist
  contributor: Governance Analysis Chapter
  last_reviewed: 2024-04-09
  confidence: high
stages:
  - name: Queue Reconnaissance
    objective: Understand enqueue rules, priority sorting, and cancellation hooks.
    actions:
      - Review proposal struct fields (eta, priority, dependency arrays).
      - Enumerate roles allowed to cancel or expedite proposals.
      - Inspect timestamp math for rounding errors.
    detection_signatures:
      onchain:
        - ProposalQueued events with identical eta
        - CancelledProposal events preceding queue reorder
      offchain:
        - governance forums noting queue anomalies
    poc_snippet: |
      (uint256 eta,,) = timelock.queuedTransactions(id);
      emit log_uint(eta);
  - name: Queue Skewing
    objective: Craft operations that shift queue ordering in favor of attacker proposal.
    actions:
      - Use flash-loaned voting power to submit malicious proposal with minimal delay.
      - Cancel benign proposals to free priority slots.
      - Exploit rounding bug to reduce minDelay.
    detection_signatures:
      onchain:
        - queue length drop followed by attacker submission
        - minDelay temporarily set to lower bound
      offchain:
        - governance bots flagging sudden reordering
    poc_snippet: |
      timelock.queueTransaction(payload, block.timestamp + 1);
  - name: Execution
    objective: Execute malicious proposal before defenders can react.
    actions:
      - Call executeTransaction as soon as minDelay satisfied.
      - Batch transfer funds or upgrade contracts.
      - Revoke admin rights to prevent rollback.
    detection_signatures:
      onchain:
        - ExecuteTransaction events referencing attacker payload
        - Timelock admin updated within same block
      offchain:
        - DAO channels reporting unexpected execution
    poc_snippet: |
      timelock.executeTransaction(payload);
      assertEq(target.owner(), attacker);
  - name: Reporting and Mitigation
    objective: Provide fix recommendations and reproduction data.
    actions:
      - Document queue ordering weakness.
      - Suggest per-proposal minDelay and cancellation guards.
      - Provide reproduction script and timeline.
    detection_signatures:
      onchain:
        - minDelayUpdated event raising delay post-report
      offchain:
        - governance vote ratifying queue hardening
    poc_snippet: |
      console.log("Queue manipulation documented");
detection_signatures:
  onchain:
    - multiple proposals queued with identical eta followed by rapid execution
    - cancellations preceding malicious execution within same epoch
  offchain:
    - governance analytics alerting to queue reorder events
poc_skeletons:
  foundry:
    required_imports:
      - forge-std/Test.sol
    setup_outline: Deploy governance token, timelock, and target contract; mint attacker voting power.
    exploit_outline: Queue malicious proposal with short eta, cancel benign proposals, execute payload.
    validation_outline: Assert attacker controls target contract and queue order changed.
    code: |
      // SPDX-License-Identifier: MIT
      pragma solidity ^0.8.19;

      import "forge-std/Test.sol";
      import "../src/{contract_name}.sol";

      contract GovernanceQueueExploit is Test {
          {contract_name} timelock;
          address attacker = address(this);

          function setUp() public {
              timelock = new {contract_name}();
          }

          function testQueueManipulation() public {
              bytes32 id = timelock.queueTransaction(abi.encodeWithSignature("drain()"), block.timestamp + 1);
              timelock.cancelTransaction(previousId);
              vm.warp(block.timestamp + 2);
              timelock.executeTransaction(id);
              // TODO: asset assertions
          }
      }
  hardhat:
    required_imports:
      - "hardhat"
    setup_outline: Deploy governance stack, prepare attacker voting power, script queue manipulations.
    exploit_outline: Submit malicious proposal, reorder queue, execute after delay.
    validation_outline: Confirm target contract ownership or fund transfer to attacker.
    code: |
      const { ethers } = require("hardhat");

      describe("Governance Queue Manipulation", function () {
        it("executes attacker proposal early", async function () {
          // TODO: orchestrate queue manipulation flow
        });
      });
metrics:
  baseline_success_rate: 0.37
  references_tested: 4
