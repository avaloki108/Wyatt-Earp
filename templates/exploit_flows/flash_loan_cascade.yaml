metadata:
  id: flash-loan-cascade-001
  name: Flash Loan Cascade Drain
  description: >-
    Captures chained flash loan primitives that recursively trigger price
    manipulation, reentrancy, and forced liquidation across multiple lending
    venues.
  severity: critical
  tags:
    - flash_loan
    - cascade
    - multi_protocol
  vulnerability_classes:
    - flash_loan_cascade
    - cross_protocol_liquidation
  historical_references:
    - incident: bZx flash loan cascade
      year: 2020
      details: Combined flash loan and oracle manipulation drained collateral pools.
      link: https://bzx.network/blog/incident
    - incident: Cream Finance multi-asset drain
      year: 2021
      details: Recursive flash loans manipulated collateral valuations across integrations.
      link: https://cream.finance/blog/postmortem
provenance:
  source: Cross-Protocol Attack Library
  contributor: DeFi Cascade Working Group
  last_reviewed: 2024-03-27
  confidence: high
stages:
  - name: Protocol Mapping
    objective: Identify all flash lenders, collateral pools, and oracle dependencies involved in the cascade.
    actions:
      - Enumerate accessible flash loan providers and max borrowable amounts.
      - Trace downstream protocol hooks triggered by borrowed assets.
      - Build dependency graph of oracles and liquidation thresholds.
    detection_signatures:
      onchain:
        - batched multicall referencing multiple lending venues
        - FlashLoan(address borrower, uint256 amount) events in same block across protocols
      offchain:
        - Graph analysis showing cyclical asset dependencies
    poc_snippet: |
      console.log("Max loan", lender.getMaxFlashLoan(address(token)));
  - name: Cascade Setup
    objective: Craft sequence of swaps, oracle writes, and re-entries executed inside flash loan callback.
    actions:
      - Arrange multi-hop swaps to skew TWAP oracles.
      - Queue reentrant calls to lending adapters while balance inflated.
      - Schedule liquidation triggers reliant on manipulated oracle values.
    detection_signatures:
      onchain:
        - nested call depth > 5 within single transaction
        - oracle update events preceding liquidation triggers
      offchain:
        - MEV bundle traces showing alternating borrow/repay actions
    poc_snippet: |
      lender.flashLoan(address(this), token, amount, abi.encode("cascade"));
  - name: Execution and Extraction
    objective: Run flash loan and cascade through steps to siphon collateral.
    actions:
      - Execute flash loan, call cascade function.
      - Force collateral liquidation and withdraw seized assets.
      - Repay flash loan while retaining profit.
    detection_signatures:
      onchain:
        - LiquidationCall events referencing attacker's address
        - repayFlashLoan executed with manipulated collateral
      offchain:
        - trading venue depth collapse for targeted pair
    poc_snippet: |
      function executeOperation(...) external returns (bool) {
          _manipulateOracle();
          _triggerLiquidations();
          _extractCollateral();
          return true;
      }
  - name: Cleanup and Reporting
    objective: Document cascade dependencies and recommend mitigations.
    actions:
      - Summarize sequence diagrams for involved protocols.
      - Provide on-chain transaction trace with annotations.
      - Outline guard suggestions (rate limits, isolated oracles).
    detection_signatures:
      onchain:
        - debt position reopened after repay
      offchain:
        - governance or incident response alerts referencing cascade attack
    poc_snippet: |
      console.log("Cascade sequence completed");
detection_signatures:
  onchain:
    - multiple flashLoan callbacks chained in transaction traces
    - abnormal oracle updates without price feed confirmation
  offchain:
    - MEV relay bundles containing alternating borrow/repay steps
poc_skeletons:
  foundry:
    required_imports:
      - forge-std/Test.sol
    setup_outline: Deploy or fork protocols, seed liquidity pools, configure oracle mocks.
    exploit_outline: Borrow via flash loan, manipulate oracle in callback, liquidate victims, repay loan.
    validation_outline: Assert protocol balances decreased and attacker retained profit while flash loan repaid.
    code: |
      // SPDX-License-Identifier: MIT
      pragma solidity ^0.8.19;

      import "forge-std/Test.sol";
      import "../src/{contract_name}.sol";

      contract FlashLoanCascadeExploit is Test {
          {contract_name} target;
          address attacker = address(this);

          function setUp() public {
              target = new {contract_name}();
              vm.deal(address(target), 1_000 ether);
          }

          function testCascadeDrain() public {
              uint256 amount = target.maxFlashLoan();
              target.initiateCascade(amount);

              // Assertions placeholder
              assertGt(address(attacker).balance, 0);
          }
      }
  hardhat:
    required_imports:
      - "hardhat"
    setup_outline: Use mainnet fork, impersonate large liquidity providers, ensure flash lenders funded.
    exploit_outline: Run scripted cascade with ethers.js, track each step in console logs.
    validation_outline: Verify attacker profit and ensure flash loan debt repaid.
    code: |
      const { ethers } = require("hardhat");

      describe("Flash Loan Cascade", function () {
        it("executes cascade steps", async function () {
          // TODO: orchestrate cascade across protocols
        });
      });
metrics:
  baseline_success_rate: 0.46
  references_tested: 6
