metadata:
  id: cross-chain-fee-001
  name: Cross-Chain Fee Desynchronization Attack
  description: >-
    Describes leveraging mismatched bridge fee accounting between source and
    destination chains to withdraw more assets than deposited when relayer fee
    credits desynchronize.
  severity: medium
  tags:
    - cross_chain
    - fee_desync
    - accounting
  vulnerability_classes:
    - cross_chain_fee_desync
    - accounting_mismatch
  historical_references:
    - incident: Nomad fee accounting bug
      year: 2022
      details: Incorrect fee bookkeeping allowed repeated withdrawals.
      link: https://nomad.xyz/postmortem
    - incident: Axelar fee credit desync report
      year: 2023
      details: Fee rebate module failed to burn credits on destination chain.
      link: https://axelar.network/blog
provenance:
  source: Cross-Chain Accounting Circle
  contributor: Bridge Reliability Team
  last_reviewed: 2024-03-12
  confidence: medium
stages:
  - name: Fee Model Discovery
    objective: Understand fee credit issuance and reconciliation process.
    actions:
      - Inspect deposit fee calculation and credit minting functions.
      - Review destination chain credit burn mechanism.
      - Analyze reconciliation events frequency.
    detection_signatures:
      onchain:
        - FeeCreditMinted events without matching burn
        - discrepancy between totalDeposits and totalCredits
      offchain:
        - relayer accounting dashboards showing negative balance
    poc_snippet: |
      uint256 credits = bridge.viewCredits(attacker);
      emit log_uint(credits);
  - name: Desync Triggering
    objective: Force divergence between credited fees and actual burns.
    actions:
      - Spam small deposits to inflate fee credits.
      - Trigger withdrawals on destination chain while skipping reconciliation.
      - Exploit rounding differences between chains.
    detection_signatures:
      onchain:
        - multiple small deposits followed by large withdrawal
        - reconciliation event skipped for > N blocks
      offchain:
        - relayer alerts for fee imbalance
    poc_snippet: |
      bridge.deposit{value: 0.1 ether}(token, recipient);
  - name: Extraction
    objective: Withdraw assets using accumulated fee credits beyond legitimate balance.
    actions:
      - Call withdrawWithCredits on destination chain.
      - Convert fee credits to tokens repeatedly before reconciliation.
      - Cycle assets back to source to repeat.
    detection_signatures:
      onchain:
        - WithdrawWithCredits events exceeding deposits
        - feeCredits(attacker) remaining positive post-withdrawal
      offchain:
        - monitoring showing negative relayer profit
    poc_snippet: |
      bridge.withdrawWithCredits(attacker, token, amount);
  - name: Documentation and Mitigation
    objective: Capture accounting mismatch and advise fixes.
    actions:
      - Provide ledger comparison between chains.
      - Recommend atomic burn/mint or single-source accounting.
      - Suggest alerts for credit accumulation thresholds.
    detection_signatures:
      onchain:
        - auditLog() showing mismatched credits vs burns
      offchain:
        - incident ticket referencing fee desync
    poc_snippet: |
      console.log("Fee credits delta", bridge.viewCredits(attacker));
detection_signatures:
  onchain:
    - fee credit supply increasing while bridge vault static
    - withdrawal amounts exceeding deposit sum by fee rate
  offchain:
    - accounting dashboards raising fee imbalance alerts
poc_skeletons:
  foundry:
    required_imports:
      - forge-std/Test.sol
    setup_outline: Deploy dual-chain bridge mocks with fee credits, seed vault balances, assign attacker.
    exploit_outline: Mint excess fee credits via repeated deposits, withdraw using credits before burn.
    validation_outline: Assert attacker gains assets and credits remain positive post-withdrawal.
    code: |
      // SPDX-License-Identifier: MIT
      pragma solidity ^0.8.19;

      import "forge-std/Test.sol";
      import "../src/{contract_name}.sol";

      contract CrossChainFeeDesyncExploit is Test {
          {contract_name} bridge;
          address attacker = address(this);

          function setUp() public {
              bridge = new {contract_name}();
              bridge.seedVault{value: 100 ether}();
          }

          function testFeeDesync() public {
              for (uint256 i = 0; i < 10; i++) {
                  bridge.deposit{value: 0.1 ether}(address(0), attacker);
              }
              bridge.withdrawWithCredits(attacker, address(0), 2 ether);
              assertGt(attacker.balance, 1 ether);
          }
      }
  hardhat:
    required_imports:
      - "hardhat"
    setup_outline: Deploy bridge mock on dual networks (forked), simulate fee credit accumulation.
    exploit_outline: Reuse credits without burn, drain vault, verify ledger mismatch.
    validation_outline: Ensure credits remain > 0 and vault decreased.
    code: |
      const { ethers } = require("hardhat");

      describe("Cross-Chain Fee Desync", function () {
        it("withdraws with unburned credits", async function () {
          // TODO: implement credit drain scenario
        });
      });
metrics:
  baseline_success_rate: 0.28
  references_tested: 3
